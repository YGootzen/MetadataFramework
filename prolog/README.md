# Explanation of the logical programming approach
An automated search for a path, i.e. a way to combine the data sources studied, helps us to determine the answer to the puzzle. The nature of the definitions and the logical setup of the framework enables us to implement these steps in a logic programming language. In logic programming, the interpreter is provided with facts and logical rules and is asked to answer queries on whether certain statements evaluate to true or false. An example of a logical programming language is SWI-Prolog, and it has been used to implement the steps described in this paper. The general idea behind the implementation is to demonstrate the practicality of the metadata-based framework. All basic manipulations and models relevant to the mobility case study have been implemented as a proof of concept. The full code is available as scripts on this GitHub page.

When viewed from a logic programming perspective, a data source is considered a fact that contains information on the included variables and their aggregation levels. Manipulations such as conversion, aggregation, and combining were implemented as logical rules. A data set can be constructed (evaluated to true) if it can be created from one or more other data sources through a sequence of manipulations and/or modelling steps. 

Aggregation and conversion are implemented as directed (a)cyclic graphs for each variable. To determine whether one variable $v_i$ can be (indirectly) aggregated or converted to another variable $v_j$, the program simply answers the question \enquote{is there a path from node $v_i$ to node $v_j$?}. This question is answered by performing an exhaustive search of all possible edge combinations for a path connecting the two nodes. For the manipulation combination, two sources are required that produce a third. This was implemented using an AND-structure, as known from logical AND-gates. This can be imagined as an edge in a graph that originates at two nodes and comes together in one different node.  Note that combinations of more than two sources can always be described by chaining multiple AND-edges. Models need to be implemented as unique rules due to their individual nature.

With data sources as facts and manipulations as rules, the basis of the framework is implemented. Let us call this the low abstraction layer of the program. A second, high, abstraction layer comes into view when a graph is formed with nodes representing the data sets, consisting of sets of left- and right-hand variables and context, and (AND-)edges representing the basic manipulations and models possible. The answer to the data combination question is obtained by determining the answer to the question \enquote{is there a path from the origin to the intended data source?}. To enable the question to be answered, it is required to add a \textit{origin} node to each of the starting data sets nodes. Whenever an AND-edge is encountered during the search, two paths are needed as input: one from the origin to the first input of the AND-edge, and one from the origin to the second input of the double AND-edge. In this way, the possible combinations of a set of data sources can be determined with the logical steps implemented. Both abstraction layers have been successfully implemented independent from one another. 

So far, we have used the Prolog implementation to search for the path(s) between the origin and the intended outcome for a limited number of cases. The exhaustive search approach of Prolog guarantees that if there exists a path between the origin and the intended outcome it will be found. For cases that include a limited (small) number of sources, the current implementation, integrating both abstraction layers, has been shown to correctly identify valid paths as well as determine when a path does not exist. However, the downside of an exhaustive search is that the number of potential paths that need to be checked quickly becomes a huge combinatorial challenge, particularly when the number of available data sources increases. Hence, at the moment only cases were investigated by the Prolog implementation that could be solved by hand by any researcher.
